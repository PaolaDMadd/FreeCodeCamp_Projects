<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Technical Documentation Page</title>
    <script src="https://code.iconify.design/1/1.0.6/iconify.min.js"></script>
    <link rel="stylesheet" href="Technical.css">
</head>


<!-- User Story #14: On regular sized devices (laptops, desktops), the element with id="navbar" should be shown on the left side of the screen and should always be visible to the user. -->
<nav id="navbar">
   
    <header><span class="iconify" data-icon="logos-clojure" data-inline="false"></span> <h1 class="header_text"> Clojure technical documentation</h1> </header>
    <ul id="link-container">
        <li> <a class="nav-link" href="#main-doc">Rationale</a></li>
        <li> <a class="nav-link" href="#Why_clojure">Why Clojure?</a></li>
        <li> <a class="nav-link" href="#Lisp_is_a_good_thing">Lisp is a good thing</a></li>
        <li> <a class="nav-link" href="#Functional_programming_is_a_good_thing">Functional programming is a good thing</a></li>
        <li> <a class="nav-link" href="#Languages_and_Platforms">Languages and Platforms</a></li>
        <li> <a class="nav-link" href="#Object_Orientation_is_overrated">Object Orientation is overrated</a></li>
        <li> <a class="nav-link" href="#Polymorphism_is_a_good_thing">Polymorphism is a good thing</a></li>
        <li> <a class="nav-link" href="#Concurrency_and_the_multi-core_future">Concurrency and the multi-core future</a></li>
    </ul>
</nav>

<!-- User Story #1: I can see a main element with a corresponding id="main-doc", which contains the page's main content (technical documentation).
User Story #2: Within the #main-doc element, I can see several section elements, each with a class of main-section. There should be a minimum of 5.
User Story #3: The first element within each .main-section should be a header element which contains text that describes the topic of that section.
User Story #4: Each section element with the class of main-section should also have an id that corresponds with the text of each header contained within it. 
Any spaces should be replaced with underscores (e.g. The section that contains the header "JavaScript and Java" should have a corresponding id="JavaScript_and_Java").
User Story #5: The .main-section elements should contain at least 10 p elements total (not each).
User Story #6: The .main-section elements should contain at least 5 code elements total (not each).
User Story #7: The .main-section elements should contain at least 5 li items total (not each).
User Story #8: I can see a nav element with a corresponding id="navbar".

User Story #15: My Technical Documentation page should use at least one media query.-->


<body>

    <main id="main-doc"> <p> main content (technical documentation).</p><h2>OVERVIEW</h2>
        <!--  There should be a minimum of 5. and an id that corresponds with the text of each header contained within it -->
        <!-- use underscore (e.g. The section that contains the header "JavaScript and Java" should have a corresponding id="JavaScript_and_Java"). -->
        <!-- User Story #5: The .main-section elements should contain at least 10 p elements total (not each).
        User Story #6: The .main-section elements should contain at least 5 code elements total (not each).
        User Story #7: The .main-section elements should contain at least 5 li items total (not each). -->


        
        <h3>Rationale</h3>
        <p> Customers and stakeholders have substantial investments in, and are comfortable with the performance, security and stability of, industry-standard platforms like the JVM. While Java developers may envy the succinctness, flexibility and productivity of dynamic languages, they have concerns about running on customer-approved infrastructure, access to their existing code base and libraries, and performance. In addition, they face ongoing problems dealing with concurrency using native threads and locking. Clojure is an effort in pragmatic dynamic language design in this context. It endeavors to be a general-purpose language suitable in those areas where Java is suitable. It reflects the reality that, for the concurrent programming future, pervasive, unmoderated mutation simply has to go.

            Clojure meets its goals by: embracing an industry-standard, open platform - the JVM; modernizing a venerable language - Lisp; fostering functional programming with immutable persistent data structures; and providing built-in concurrency support via software transactional memory and asynchronous agents. The result is robust, practical, and fast.
            
            Clojure has a distinctive approach to state and identity.</p>


        <section id="Why_clojure" class="main-section">
            <h3>Why Clojure?</h3>

            <p>Why did I write yet another programming language? Basically because I wanted:

                A Lisp
                for Functional Programming
                symbiotic with an established Platform
                designed for Concurrency
                and couldn’t find one. Here’s an outline of some of the motivating ideas behind Clojure.
            </p>
        </section>

        <section id="Lisp_is_a_good_thing" class="main-section">
            <h3>Lisp is a good thing</h3>
            <p>Often emulated/pillaged, still not duplicated
                Lambda calculus yields an extremely small core
                Almost no syntax
                Core advantage still code-as-data and syntactic abstraction
                What about the standard Lisps (Common Lisp and Scheme)?
                Slow/no innovation post standardization
                Core data structures mutable, not extensible
                No concurrency in specs
                Good implementations already exist for JVM (ABCL, Kawa, SISC et al)
                Standard Lisps are their own platforms
                Clojure is a Lisp not constrained by backwards compatibility
                Extends the code-as-data paradigm to maps and vectors
                Defaults to immutability
                Core data structures are extensible abstractions
                Embraces a platform (JVM)</p>

        </section>
        <section id="Functional_programming_is_a_good_thing" class="main-section">
             <h3>Functional programming is a good thing</h3>

             <p>Immutable data + first-class functions
                Could always be done in Lisp, by discipline/convention
                But if a data structure can be mutated, dangerous to presume it won’t be
                In traditional Lisp, only the list data structure is structurally recursive
                Pure functional languages tend to strongly static types
                Not for everyone, or every task
                Clojure is a functional language with a dynamic emphasis
                All data structures immutable & persistent, supporting recursion
                Heterogeneous collections, return types
                Dynamic polymorphism</p>

        </section>
        <section id="Languages_and_Platforms" class="main-section">
            <h3>Languages and Platforms</h3>
            <p>VMs, not OSes, are the platforms of the future, providing:
                Type system
                Dynamic enforcement and safety
                Libraries
                Abstract away OSes
                Huge set of facilities
                Built-in and 3rd-party
                Memory and other resource management
                GC is platform, not language, facility
                Bytecode + JIT compilation
                Abstracts away hardware
                Language as platform vs. language + platform
                Old way - each language defines its own runtime
                GC, bytecode, type system, libraries etc
                New way (JVM, .Net)
                Common runtime independent of language
                Language built for platform vs language ported-to platform
                Many new languages still take 'Language as platform' approach
                When ported, have platform-on-platform issues
                Memory management, type-system, threading issues
                Library duplication
                If original language based on C, some extension libraries written in C don’t come over
                Platforms are dictated by clients
                'Must run on JVM' or .Net vs 'must run on Unix' or Windows
                JVM has established track record and trust level
                Now also open source
                Interop with other code required
                C linkage insufficient these days
                Java/JVM is language + platform
                Not the original story, but other languages for JVM always existed, now embraced by Sun
                Java can be tedious, insufficiently expressive
                Lack of first-class functions, no type inference, etc
                Ability to call/consume Java is critical
                Clojure is the language, JVM the platform</p>
        </section>

        <section id="Object_Orientation_is_overrated" class="main-section">
            <h3>Object Orientation is overrated</h3>
            <p>Born of simulation, now used for everything, even when inappropriate
                Encouraged by Java/C# in all situations, due to their lack of (idiomatic) support for anything else
                Mutable stateful objects are the new spaghetti code
                Hard to understand, test, reason about
                Concurrency disaster
                Inheritance is not the only way to do polymorphism
                "It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures." - Alan J. Perlis
                Clojure models its data structures as immutable objects represented by interfaces, and otherwise does not offer its own class system.
                Many functions defined on few primary data structures (seq, map, vector, set).
                Write Java in Java, consume and extend Java from Clojure.
                </p>
        </section>

        <section id="Polymorphism_is_a_good_thing" class="main-section">
            <h3>Polymorphism is a good thing</h3>
            <p>Switch statements, structural matching etc yield brittle systems
                Polymorphism yields extensible, flexible systems
                Clojure multimethods decouple polymorphism from OO and types
                Supports multiple taxonomies
                Dispatches via static, dynamic or external properties, metadata, etc</p>
        </section>
        <section id="Concurrency_and_the_multi-core_future" class="main-section">
            <h3>Concurrency and the multi-core future</h3>
            <p>Immutability makes much of the problem go away
                Share freely between threads
                But changing state a reality for simulations and for in-program proxies to the outside world
                Locking is too hard to get right over and over again
                Clojure’s software transactional memory and agent systems do the hard part
                In short, I think Clojure occupies a unique niche as a functional Lisp for the JVM with strong concurrency support. 
                Check out some of the features or get started with Clojure.</p>
        </section>

    </main>

</body>

</html>